<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构算法作业答案 | 雲陽的博客</title><meta name="author" content="雲陽"><meta name="copyright" content="雲陽"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第二章2.1112345678910Status Insert_SqList(SqList &amp;va,int x)&#x2F;&#x2F;把x插入递增有序表va中&amp;#123;  if(va.length+1&gt;va.listsize) return ERROR;  va.length++;  for(i&#x3D;va.length-1;va.elem[i]&gt;x&amp;&amp;i&gt;&#x3D;0;i--)">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构算法作业答案">
<meta property="og:url" content="https://jiahuikang.github.io/2023/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%9A%E7%AD%94%E6%A1%88/index.html">
<meta property="og:site_name" content="雲陽的博客">
<meta property="og:description" content="第二章2.1112345678910Status Insert_SqList(SqList &amp;va,int x)&#x2F;&#x2F;把x插入递增有序表va中&amp;#123;  if(va.length+1&gt;va.listsize) return ERROR;  va.length++;  for(i&#x3D;va.length-1;va.elem[i]&gt;x&amp;&amp;i&gt;&#x3D;0;i--)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jiahuikang.github.io/img/whiteBG.jpg">
<meta property="article:published_time" content="2023-06-21T15:08:47.096Z">
<meta property="article:modified_time" content="2023-06-21T15:11:26.181Z">
<meta property="article:author" content="雲陽">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jiahuikang.github.io/img/whiteBG.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://jiahuikang.github.io/2023/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%9A%E7%AD%94%E6%A1%88/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构算法作业答案',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-21 23:11:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://jiahuikang.github.io/img/whiteBG.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">雲陽的博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about"><i class="fa-fw /about/"></i><span> 0</span></a></li><li><a class="site-page child" href="/myself"><i class="fa-fw /myself/"></i><span> 1</span></a></li><li><a class="site-page child" href="/butterfly"><i class="fa-fw https://github.com/jerryc127/hexo-theme-butterfly/"></i><span> 2</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构算法作业答案</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-21T15:08:47.096Z" title="发表于 2023-06-21 23:08:47">2023-06-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-21T15:11:26.181Z" title="更新于 2023-06-21 23:11:26">2023-06-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构算法作业答案"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="2-11"><a href="#2-11" class="headerlink" title="2.11"></a>2.11</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Insert_SqList</span><span class="params">(SqList &amp;va,<span class="type">int</span> x)</span><span class="comment">//把x插入递增有序表va中</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va.length+<span class="number">1</span>&gt;va.listsize) <span class="keyword">return</span> ERROR;</span><br><span class="line">  va.length++;</span><br><span class="line">  <span class="keyword">for</span>(i=va.length<span class="number">-1</span>;va.elem[i]&gt;x&amp;&amp;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    va.elem[i+<span class="number">1</span>]=va.elem[i];</span><br><span class="line">  va.elem[i+<span class="number">1</span>]=x;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//Insert_SqList </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-19"><a href="#2-19" class="headerlink" title="2.19"></a>2.19</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Delete_Between</span><span class="params">(Linklist &amp;L,<span class="type">int</span> mink,<span class="type">int</span> maxk)</span><span class="comment">//删除元素递增排列的链表L中值大于mink且小于maxk的所有元素</span></span><br><span class="line">&#123;</span><br><span class="line">  p=L;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;next-&gt;data&lt;=mink) p=p-&gt;next; <span class="comment">//p是最后一个不大于mink的元素</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;next)    <span class="comment">//如果还有比mink更大的元素</span></span><br><span class="line">  &#123;</span><br><span class="line">    q=p-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(q-&gt;data&lt;maxk) q=q-&gt;next; <span class="comment">//q是第一个不小于maxk的元素</span></span><br><span class="line">    p-&gt;next=q;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">//Delete_Between </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-22"><a href="#2-22" class="headerlink" title="2.22"></a>2.22</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LinkList_reverse</span><span class="params">(Linklist &amp;L)</span><span class="comment">//链表的就地逆置;为简化算法,假设表长大于2</span></span><br><span class="line">&#123;</span><br><span class="line">  p=L-&gt;next;q=p-&gt;next;s=q-&gt;next;p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span>(s-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    q-&gt;next=p;p=q;</span><br><span class="line">    q=s;s=s-&gt;next; <span class="comment">//把L的元素逐个插入新表表头</span></span><br><span class="line">  &#125;</span><br><span class="line">  q-&gt;next=p;s-&gt;next=q;L-&gt;next=s;</span><br><span class="line">&#125;<span class="comment">//LinkList_reverse</span></span><br><span class="line">分析:本算法的思想是,逐个地把L的当前元素q插入新的链表头部,p为新表表头.</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-25"><a href="#2-25" class="headerlink" title="2.25"></a>2.25</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SqList_Intersect</span><span class="params">(SqList A,SqList B,SqList &amp;C)</span><span class="comment">//求元素递增排列的线性表A和B的元素的交集并存入C中</span></span><br><span class="line">&#123;</span><br><span class="line">  i=<span class="number">1</span>;j=<span class="number">1</span>;k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(A.elem[i]&amp;&amp;B.elem[j])</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(A.elem[i]&lt;B.elem[j]) i++;</span><br><span class="line">    <span class="keyword">if</span>(A.elem[i]&gt;B.elem[j]) j++;</span><br><span class="line">    <span class="keyword">if</span>(A.elem[i]==B.elem[j])</span><br><span class="line">    &#123;</span><br><span class="line">      C.elem[++k]=A.elem[i]; <span class="comment">//当发现了一个在A,B中都存在的元素,</span></span><br><span class="line">      i++;j++; <span class="comment">//就添加到C中</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//while</span></span><br><span class="line">&#125;<span class="comment">//SqList_Intersect</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-26"><a href="#2-26" class="headerlink" title="2.26"></a>2.26</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LinkList_Intersect</span><span class="params">(LinkList A,LinkList B,LinkList &amp;C)</span><span class="comment">//在链表结构上重做上题</span></span><br><span class="line">&#123;</span><br><span class="line">  p=A-&gt;next;q=B-&gt;next;</span><br><span class="line">  pc=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); </span><br><span class="line"> C=pc;</span><br><span class="line">  <span class="keyword">while</span>(p&amp;&amp;q)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data&lt;q-&gt;data) p=p-&gt;next;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;data&gt;q-&gt;data) q=q-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      s=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">      s-&gt;data=p-&gt;data;</span><br><span class="line">      pc-&gt;next=s;pc=s;</span><br><span class="line">      p=p-&gt;next;q=q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//while</span></span><br><span class="line">&#125;<span class="comment">//LinkList_Intersect </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-33"><a href="#2-33" class="headerlink" title="* 2.33"></a>* 2.33</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">LinkList_Divide</span><span class="params">(LinkList &amp;L,CiList &amp;A,CiList &amp;B,CiList &amp;C)</span><span class="comment">//把单链表L的元素按类型分为三个循环链表.CiList为带头结点的单循环链表类型.</span></span><br><span class="line">&#123;</span><br><span class="line">  s=L-&gt;next;</span><br><span class="line">  A=(CiList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CiLNode));p=A;</span><br><span class="line">  B=(CiList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CiLNode));q=B;</span><br><span class="line">  C=(CiList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CiLNode));r=C; <span class="comment">//建立头结点</span></span><br><span class="line">  <span class="keyword">while</span>(s)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(isalphabet(s-&gt;data))</span><br><span class="line">    &#123;</span><br><span class="line">      p-&gt;next=s;p=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s-&gt;data))</span><br><span class="line">    &#123;</span><br><span class="line">      q-&gt;next=s;q=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      r-&gt;next=s;r=s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//while</span></span><br><span class="line">  p-&gt;next=A;q-&gt;next=B;r-&gt;next=C; <span class="comment">//完成循环链表</span></span><br><span class="line">&#125;<span class="comment">//LinkList_Divide </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="3-17"><a href="#3-17" class="headerlink" title="* 3.17"></a>* 3.17</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">IsReverse</span><span class="params">()</span><span class="comment">//判断输入的字符串中&#x27;&amp;&#x27;前和&#x27;&amp;&#x27;后部分是否为逆串,是则返回1,否则返回0</span></span><br><span class="line">&#123;</span><br><span class="line">  InitStack(s);</span><br><span class="line">  <span class="keyword">while</span>((e=getchar())!=<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(e==’@’) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不允许在’&amp;’之前出现’@’</span></span><br><span class="line">    push(s,e); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>( (e=getchar())!=<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(s)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    pop(s,c);</span><br><span class="line">    <span class="keyword">if</span>(e!=c) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!StackEmpty(s)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//IsReverse </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-18"><a href="#3-18" class="headerlink" title="* 3.18"></a>* 3.18</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">Bracket_Test</span><span class="params">(<span class="type">char</span> *str)</span><span class="comment">//判别表达式中小括号是否匹配</span></span><br><span class="line">&#123;</span><br><span class="line">  count=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(p=str;*p;p++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(*p==<span class="string">&#x27;(&#x27;</span>) count++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*p==<span class="string">&#x27;)&#x27;</span>) count--;</span><br><span class="line">    <span class="keyword">if</span> (count&lt;<span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(count) <span class="keyword">return</span> ERROR; <span class="comment">//注意括号不匹配的两种情况</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//Bracket_Test </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-19"><a href="#3-19" class="headerlink" title="3.19"></a>3.19</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">AllBrackets_Test</span><span class="params">(<span class="type">char</span> *str)</span><span class="comment">//判别表达式中三种括号是否匹配</span></span><br><span class="line">&#123;</span><br><span class="line">  InitStack(s);</span><br><span class="line">  <span class="keyword">for</span>(p=str;*p;p++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(*p==<span class="string">&#x27;(&#x27;</span>||*p==<span class="string">&#x27;[&#x27;</span>||*p==<span class="string">&#x27;&#123;&#x27;</span>) push(s,*p);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*p==<span class="string">&#x27;)&#x27;</span>||*p==<span class="string">&#x27;]&#x27;</span>||*p==<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(StackEmpty(s)) <span class="keyword">return</span> ERROR;</span><br><span class="line">      pop(s,c);</span><br><span class="line">      <span class="keyword">if</span>(*p==<span class="string">&#x27;)&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">      <span class="keyword">if</span>(*p==<span class="string">&#x27;]&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">      <span class="keyword">if</span>(*p==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> ERROR; <span class="comment">//必须与当前栈顶括号匹配</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//for</span></span><br><span class="line">  <span class="keyword">if</span>(!StackEmpty(s)) <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//AllBrackets_Test </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-21"><a href="#3-21" class="headerlink" title="3.21"></a>3.21</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NiBoLan</span><span class="params">(<span class="type">char</span> *str,<span class="type">char</span> *new)</span><span class="comment">//把中缀表达式str转换成逆波兰式new</span></span><br><span class="line">&#123;</span><br><span class="line">  p=str;q=new; <span class="comment">//为方便起见,设str的两端都加上了优先级最低的特殊符号</span></span><br><span class="line">  InitStack(s); <span class="comment">//s为运算符栈</span></span><br><span class="line">  <span class="keyword">while</span>(*p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(*p是字母)) *q++=*p; <span class="comment">//直接输出</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      c=gettop(s);</span><br><span class="line">      <span class="keyword">if</span>(*p优先级比c高) push(s,*p);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span>(gettop(s)优先级不比*p低)</span><br><span class="line">        &#123;</span><br><span class="line">          pop(s,c);*(q++)=c;</span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line">        push(s,*p); <span class="comment">//运算符在栈内遵循越往栈顶优先级越高的原则</span></span><br><span class="line">      &#125;<span class="comment">//else</span></span><br><span class="line">    &#125;<span class="comment">//else</span></span><br><span class="line">    p++;</span><br><span class="line">  &#125;<span class="comment">//while</span></span><br><span class="line">&#125;<span class="comment">//NiBoLan //参见编译原理教材 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-28"><a href="#3-28" class="headerlink" title="3.28"></a>3.28</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitCiQueue</span><span class="params">(CiQueue &amp;Q)</span><span class="comment">//初始化循环链表表示的队列Q</span></span><br><span class="line">&#123;</span><br><span class="line">  Q=(CiLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CiLNode));</span><br><span class="line">  Q-&gt;next=Q;</span><br><span class="line">&#125;<span class="comment">//InitCiQueue </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnCiQueue</span><span class="params">(CiQueue &amp;Q,<span class="type">int</span> x)</span><span class="comment">//把元素x插入循环链表表示的队列Q,Q指向队尾元素,Q-&gt;next指向头结点,Q-&gt;next-&gt;next指向队头元素</span></span><br><span class="line">&#123;</span><br><span class="line">  p=(CiLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CiLNode));</span><br><span class="line">  p-&gt;data=x;</span><br><span class="line">  p-&gt;next=Q-&gt;next; <span class="comment">//直接把p加在Q的后面</span></span><br><span class="line">  Q-&gt;next=p;</span><br><span class="line">  Q=p;  <span class="comment">//修改尾指针</span></span><br><span class="line">&#125; </span><br><span class="line">Status <span class="title function_">DeCiQueue</span><span class="params">(CiQueue &amp;Q,<span class="type">int</span> x)</span><span class="comment">//从循环链表表示的队列Q头部删除元素x</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(Q==Q-&gt;next) <span class="keyword">return</span> INFEASIBLE; <span class="comment">//队列已空</span></span><br><span class="line">  p=Q-&gt;next-&gt;next;</span><br><span class="line">  x=p-&gt;data;</span><br><span class="line">  Q-&gt;next-&gt;next=p-&gt;next;</span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//DeCiQueue </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-31"><a href="#3-31" class="headerlink" title="* 3.31"></a>* 3.31</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Palindrome_Test</span><span class="params">()</span><span class="comment">//判别输入的字符串是否回文序列,是则返回1,否则返回0</span></span><br><span class="line">&#123;</span><br><span class="line">  InitStack(S);InitQueue(Q);</span><br><span class="line">  <span class="keyword">while</span>((c=getchar())!=<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    Push(S,c);EnQueue(Q,c); <span class="comment">//同时使用栈和队列两种结构</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(!StackEmpty(S))</span><br><span class="line">  &#123;</span><br><span class="line">    Pop(S,a);DeQueue(Q,b));</span><br><span class="line">    <span class="keyword">if</span>(a!=b) <span class="keyword">return</span> ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//Palindrome_Test </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-32"><a href="#3-32" class="headerlink" title="* 3.32"></a>* 3.32</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetFib_CyQueue</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n)</span><span class="comment">//求k阶斐波那契序列的前n+1项</span></span><br><span class="line">&#123;</span><br><span class="line">  InitCyQueue(Q); <span class="comment">//其MAXSIZE设置为k</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k<span class="number">-1</span>;i++) Q.base[i]=<span class="number">0</span>;</span><br><span class="line">  Q.base[k<span class="number">-1</span>]=<span class="number">1</span>; <span class="comment">//给前k项赋初值</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Q.base[i]);</span><br><span class="line">  <span class="keyword">for</span>(i=k;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    m=i%k;sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;k;j++) sum+=Q.base[(m+j)%k];</span><br><span class="line">    Q.base[m]=sum; <span class="comment">//求第i项的值存入队列中并取代已无用的第一项</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">//GetFib_CyQueue </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="5-31"><a href="#5-31" class="headerlink" title="5.31"></a>5.31</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.31</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">GList_Copy</span><span class="params">(GList A,GList &amp;B)</span><span class="comment">//复制广义表的递归算法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!A-&gt;tag) <span class="comment">//当结点为原子时,直接复制</span></span><br><span class="line">  &#123;</span><br><span class="line">    B-&gt;tag=<span class="number">0</span>;</span><br><span class="line">    B-&gt;atom=A-&gt;atom;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">//当结点为子表时</span></span><br><span class="line">  &#123;</span><br><span class="line">    B-&gt;tag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(A-&gt;ptr.hp)</span><br><span class="line">    &#123;</span><br><span class="line">      B-&gt;ptr.hp=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode));</span><br><span class="line">      GList_Copy(A-&gt;ptr.hp,B-&gt;ptr.hp);</span><br><span class="line">    &#125; <span class="comment">//复制表头</span></span><br><span class="line">    <span class="keyword">if</span>(A-&gt;ptr.tp)</span><br><span class="line">    &#123;</span><br><span class="line">      B-&gt;ptr.tp=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GLNode));</span><br><span class="line">      GList_Copy(A-&gt;ptr.tp,B-&gt;ptr.tp);</span><br><span class="line">    &#125; <span class="comment">//复制表尾</span></span><br><span class="line">  &#125;<span class="comment">//else</span></span><br><span class="line">&#125;<span class="comment">//GList_Copy </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-38"><a href="#5-38" class="headerlink" title="5.38"></a>5.38</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GList_PrintElem_LOrder</span><span class="params">(GList A)</span><span class="comment">//按层序输出广义表A中的所有元素</span></span><br><span class="line">&#123;</span><br><span class="line">  InitQueue(Q);</span><br><span class="line">  <span class="keyword">for</span>(p=L;p;p=p-&gt;ptr.tp) EnQueue(Q,p);</span><br><span class="line">  <span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">  &#123;</span><br><span class="line">    DeQueue(Q,r);</span><br><span class="line">    <span class="keyword">if</span>(!r-&gt;tag) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,r-&gt;atom);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">for</span>(r=r-&gt;ptr.hp;r;r=r-&gt;ptr.tp) EnQueue(Q,r); </span><br></pre></td></tr></table></figure>



<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="6-33"><a href="#6-33" class="headerlink" title="6.33"></a>6.33</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Is_Descendant_C</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span><span class="comment">//在孩子存储结构上判断u是否v的子孙,是则返回1,否则返回0</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(u==v) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(L[v])</span><br><span class="line">      <span class="keyword">if</span> (Is_Descendant(u,L[v])) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R[v])</span><br><span class="line">      <span class="keyword">if</span> (Is_Descendant(u,R[v])) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//这是个递归算法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//Is_Descendant_C </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-36"><a href="#6-36" class="headerlink" title="6.36"></a>6.36</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Bitree_Sim</span><span class="params">(Bitree B1,Bitree B2)</span><span class="comment">//判断两棵树是否相似的递归算法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!B1&amp;&amp;!B2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(B1&amp;&amp;B2&amp;&amp;Bitree_Sim(B1-&gt;lchild,B2-&gt;lchild)&amp;&amp;Bitree_Sim(B1-&gt;rchild,B2-&gt;rchild))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//Bitree_Sim </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-37"><a href="#6-37" class="headerlink" title="6.37"></a>6.37</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder_Nonrecursive</span><span class="params">(Bitree T)</span><span class="comment">//先序遍历二叉树的非递归算法</span></span><br><span class="line">&#123;</span><br><span class="line">  InitStack(S);</span><br><span class="line">  Push(S,T); <span class="comment">//根指针进栈</span></span><br><span class="line">  <span class="keyword">while</span>(!StackEmpty(S))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(Gettop(S,p)&amp;&amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">      visit(p-&gt;data);</span><br><span class="line">      push(S,p-&gt;lchild);</span><br><span class="line">    &#125; <span class="comment">//向左走到尽头</span></span><br><span class="line">    pop(S,p);</span><br><span class="line">    <span class="keyword">if</span>(!StackEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">     pop(S,p);</span><br><span class="line">     push(S,p-&gt;rchild); <span class="comment">//向右一步</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//while</span></span><br><span class="line">&#125;<span class="comment">//PreOrder_Nonrecursive </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-38"><a href="#6-38" class="headerlink" title="6.38"></a>6.38</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                     BTNode* ptr;</span><br><span class="line">                     <span class="class"><span class="keyword">enum</span> &#123;</span><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125; mark;</span><br><span class="line">                   &#125; PMType; <span class="comment">//有mark域的结点指针类型 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder_Stack</span><span class="params">(BiTree T)</span><span class="comment">//后续遍历二叉树的非递归算法,用栈</span></span><br><span class="line">&#123;</span><br><span class="line">  PMType a;</span><br><span class="line">  InitStack(S); <span class="comment">//S的元素为PMType类型</span></span><br><span class="line">  Push (S,&#123;T,<span class="number">0</span>&#125;); <span class="comment">//根结点入栈</span></span><br><span class="line">  <span class="keyword">while</span>(!StackEmpty(S))</span><br><span class="line">  &#123;</span><br><span class="line">    Pop(S,a);</span><br><span class="line">    <span class="keyword">switch</span>(a.mark)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        Push(S,&#123;a.ptr,<span class="number">1</span>&#125;); <span class="comment">//修改mark域</span></span><br><span class="line">        <span class="keyword">if</span>(a.ptr-&gt;lchild) Push(S,&#123;a.ptr-&gt;lchild,<span class="number">0</span>&#125;); <span class="comment">//访问左子树</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        Push(S,&#123;a.ptr,<span class="number">2</span>&#125;); <span class="comment">//修改mark域</span></span><br><span class="line">        <span class="keyword">if</span>(a.ptr-&gt;rchild) Push(S,&#123;a.ptr-&gt;rchild,<span class="number">0</span>&#125;); <span class="comment">//访问右子树</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        visit(a.ptr); <span class="comment">//访问结点,返回</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//while</span></span><br><span class="line">&#125;<span class="comment">//PostOrder_Stack</span></span><br><span class="line">分析:为了区分两次过栈的不同处理方式,在堆栈中增加一个mark域,mark=<span class="number">0</span>表示刚刚访问此结点,mark=<span class="number">1</span>表示左子树处理结束返回,mark=<span class="number">2</span>表示右子树处理结束返回.每次根据栈顶元素的mark域值决定做何种动作. </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-39"><a href="#6-39" class="headerlink" title="6.39"></a>6.39</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                     <span class="type">int</span> data;</span><br><span class="line">                     EBTNode *lchild;</span><br><span class="line">                     EBTNode *rchild;</span><br><span class="line">                     EBTNode *parent;</span><br><span class="line">                     <span class="class"><span class="keyword">enum</span> &#123;</span><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125; mark;</span><br><span class="line">                  &#125; EBTNode,EBitree; <span class="comment">//有mark域和双亲指针域的二叉树结点类型 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder_Nonrecursive</span><span class="params">(EBitree T)</span><span class="comment">//后序遍历二叉树的非递归算法,不用栈</span></span><br><span class="line">&#123;</span><br><span class="line">  p=T;</span><br><span class="line">  <span class="keyword">while</span>(p)</span><br><span class="line">    <span class="keyword">switch</span>(p-&gt;mark)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        p-&gt;mark=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild) p=p-&gt;lchild; <span class="comment">//访问左子树</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        p-&gt;mark=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild) p=p-&gt;rchild; <span class="comment">//访问右子树</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        visit(p);</span><br><span class="line">        p-&gt;mark=<span class="number">0</span>; <span class="comment">//恢复mark值</span></span><br><span class="line">        p=p-&gt;parent; <span class="comment">//返回双亲结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//PostOrder_Nonrecursive</span></span><br><span class="line">分析:本题思路与上一题完全相同,只不过结点的mark值是储存在结点中的,而不是暂存在堆栈中,所以访问完毕后要将mark域恢复为<span class="number">0</span>,以备下一次遍历. </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-41"><a href="#6-41" class="headerlink" title="6.41"></a>6.41</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c,k; <span class="comment">//这里把k和计数器c作为全局变量处理 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Get_PreSeq</span><span class="params">(Bitree T)</span><span class="comment">//求先序序列为k的结点的值</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(T)</span><br><span class="line">  &#123;</span><br><span class="line">    c++; <span class="comment">//每访问一个子树的根都会使前序序号计数器加1</span></span><br><span class="line">    <span class="keyword">if</span>(c==k)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Value is %d\n&quot;</span>,T-&gt;data);</span><br><span class="line">      <span class="built_in">exit</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      Get_PreSeq(T-&gt;lchild); <span class="comment">//在左子树中查找</span></span><br><span class="line">      Get_PreSeq(T-&gt;rchild); <span class="comment">//在右子树中查找</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//if</span></span><br><span class="line">&#125;<span class="comment">//Get_PreSeq</span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">  c=<span class="number">0</span>; <span class="comment">//在主函数中调用前,要给计数器赋初值0</span></span><br><span class="line">  Get_PreSeq(T,k);</span><br><span class="line">  ...</span><br><span class="line">&#125;<span class="comment">//main </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-42"><a href="#6-42" class="headerlink" title="6.42"></a>6.42</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LeafCount_BiTree</span><span class="params">(Bitree T)</span><span class="comment">//求二叉树中叶子结点的数目</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//空树没有叶子</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(!T-&gt;lchild&amp;&amp;!T-&gt;rchild) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//叶子结点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> Leaf_Count(T-&gt;lchild)+Leaf_Count(T-&gt;rchild);<span class="comment">//左子树的叶子数加上右子树的叶子数</span></span><br><span class="line">&#125;<span class="comment">//LeafCount_BiTree </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-43"><a href="#6-43" class="headerlink" title="6.43"></a>6.43</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Bitree_Revolute</span><span class="params">(Bitree T)</span><span class="comment">//交换所有结点的左右子树</span></span><br><span class="line">&#123;</span><br><span class="line">  T-&gt;lchild&lt;-&gt;T-&gt;rchild; <span class="comment">//交换左右子树</span></span><br><span class="line">  <span class="keyword">if</span>(T-&gt;lchild) Bitree_Revolute(T-&gt;lchild);</span><br><span class="line">  <span class="keyword">if</span>(T-&gt;rchild) Bitree_Revolute(T-&gt;rchild); <span class="comment">//左右子树再分别交换各自的左右子树</span></span><br><span class="line">&#125;<span class="comment">//Bitree_Revolute </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-47"><a href="#6-47" class="headerlink" title="6.47"></a>6.47</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LayerOrder</span><span class="params">(Bitree T)</span><span class="comment">//层序遍历二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">  InitQueue(Q); <span class="comment">//建立工作队列</span></span><br><span class="line">  EnQueue(Q,T);</span><br><span class="line">  <span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">  &#123;</span><br><span class="line">    DeQueue(Q,p);</span><br><span class="line">    visit(p);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild) EnQueue(Q,p-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rchild) EnQueue(Q,p-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">//LayerOrder</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-49"><a href="#6-49" class="headerlink" title="6.49"></a>6.49</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">IsFull_Bitree</span><span class="params">(Bitree T)</span><span class="comment">//判断二叉树是否完全二叉树,是则返回1,否则返回0</span></span><br><span class="line">&#123;</span><br><span class="line">  InitQueue(Q);</span><br><span class="line">  flag=<span class="number">0</span>;</span><br><span class="line">  EnQueue(Q,T); <span class="comment">//建立工作队列</span></span><br><span class="line">  <span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">  &#123;</span><br><span class="line">    DeQueue(Q,p);</span><br><span class="line">    <span class="keyword">if</span>(!p) flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      EnQueue(Q,p-&gt;lchild);</span><br><span class="line">      EnQueue(Q,p-&gt;rchild); <span class="comment">//不管孩子是否为空,都入队列</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//while</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//IsFull_Bitree</span></span><br><span class="line">分析:该问题可以通过层序遍历的方法来解决.与<span class="number">6.47</span>相比,作了一个修改,不管当前结点是否有左右孩子,都入队列.这样当树为完全二叉树时,遍历时得到是一个连续的不包含空指针的序列.反之,则序列中会含有空指针. </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-60"><a href="#6-60" class="headerlink" title="6.60"></a>6.60</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LeafCount_CSTree</span><span class="params">(CSTree T)</span><span class="comment">//求孩子兄弟链表表示的树T的叶子数目</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!T-&gt;firstchild) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//叶子结点</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(child=T-&gt;firstchild;child;child=child-&gt;nextsib)</span><br><span class="line">      count+=LeafCount_CSTree(child);</span><br><span class="line">    <span class="keyword">return</span> count; <span class="comment">//各子树的叶子数之和</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">//LeafCount_CSTree </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-62"><a href="#6-62" class="headerlink" title="6.62"></a>6.62</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetDepth_CSTree</span><span class="params">(CSTree T)</span><span class="comment">//求孩子兄弟链表表示的树T的深度</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//空树</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(maxd=<span class="number">0</span>,p=T-&gt;firstchild;p;p=p-&gt;nextsib)</span><br><span class="line">      <span class="keyword">if</span>((d=GetDepth_CSTree(p))&gt;maxd) maxd=d; <span class="comment">//子树的最大深度</span></span><br><span class="line">    <span class="keyword">return</span> maxd+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">//GetDepth_CSTree </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-65"><a href="#6-65" class="headerlink" title="6.65"></a>6.65</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> Pred,Ind; <span class="comment">//假设前序序列和中序序列已经分别储存在数组Pre和In中 </span></span><br><span class="line">Bitree <span class="title function_">Build_Sub</span><span class="params">(<span class="type">int</span> Pre_Start,<span class="type">int</span> Pre_End,<span class="type">int</span> In_Start,<span class="type">int</span> In_End)</span><span class="comment">//由子树的前序和中序序列建立其二叉链表</span></span><br><span class="line">&#123;</span><br><span class="line">  sroot=(BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode)); <span class="comment">//建根</span></span><br><span class="line">  sroot-&gt;data=Pre[Pre_Start];</span><br><span class="line">  <span class="keyword">for</span>(i=In_Start;In[i]!=sroot-&gt;data;i++); <span class="comment">//在中序序列中查找子树根</span></span><br><span class="line">  leftlen=i-In_Start;</span><br><span class="line">  rightlen=In_End-i; <span class="comment">//计算左右子树的大小</span></span><br><span class="line">  <span class="keyword">if</span>(leftlen)</span><br><span class="line">  &#123;</span><br><span class="line">    lroot=Build_Sub(Pre_Start+<span class="number">1</span>,Pre_Start+leftlen,In_Start,In_Start+leftlen<span class="number">-1</span>);</span><br><span class="line">    sroot-&gt;lchild=lroot;</span><br><span class="line">  &#125; <span class="comment">//建左子树,注意参数表的计算</span></span><br><span class="line">  <span class="keyword">if</span>(rightlen)</span><br><span class="line">  &#123;</span><br><span class="line">    rroot=Build_Sub(Pre_End-rightlen+<span class="number">1</span>,Pre_End,In_End-rightlen+<span class="number">1</span>,In_End);</span><br><span class="line">    sroot-&gt;rchild=rroot;</span><br><span class="line">  &#125; <span class="comment">//建右子树,注意参数表的计算</span></span><br><span class="line">  <span class="keyword">return</span> sroot; <span class="comment">//返回子树根</span></span><br><span class="line">&#125;<span class="comment">//Build_Sub </span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  Build_Sub(<span class="number">1</span>,n,<span class="number">1</span>,n); <span class="comment">//初始调用参数,n为树结点总数</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">分析:本算法利用了这样一个性质,即一棵子树在前序和中序序列中所占的位置总是连续的.因此,就可以用起始下标和终止下标来确定一棵子树.Pre_Start,Pre_End,In_Start和In_End分别指示子树在前序子序列里的起始下标,终止下标,和在中序子序列里的起始和终止下标. </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h3 id="7-15"><a href="#7-15" class="headerlink" title="7.15"></a>7.15</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本题中的图G均为有向无权图,其余情况容易由此写出</span></span><br><span class="line">Status <span class="title function_">Insert_Vex</span><span class="params">(MGraph &amp;G, <span class="type">char</span> v)</span><span class="comment">//在邻接矩阵表示的图G上插入顶点v</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(G.vexnum+<span class="number">1</span>)&gt;MAX_VERTEX_NUM <span class="keyword">return</span> INFEASIBLE;</span><br><span class="line">  G.vexs[++G.vexnum]=v;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//Insert_Vex </span></span><br><span class="line">Status <span class="title function_">Insert_Arc</span><span class="params">(MGraph &amp;G,<span class="type">char</span> v,<span class="type">char</span> w)</span><span class="comment">//在邻接矩阵表示的图G上插入边(v,w)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>((i=LocateVex(G,v))&lt;<span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>((j=LocateVex(G,w))&lt;<span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(i==j) <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(!G.arcs[i][j].adj)</span><br><span class="line">  &#123;</span><br><span class="line">    G.arcs[i][j].adj=<span class="number">1</span>;</span><br><span class="line">    G.arcnum++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//Insert_Arc </span></span><br><span class="line">Status <span class="title function_">Delete_Vex</span><span class="params">(MGraph &amp;G,<span class="type">char</span> v)</span><span class="comment">//在邻接矩阵表示的图G上删除顶点v</span></span><br><span class="line">&#123;</span><br><span class="line">  n=G.vexnum;</span><br><span class="line">  <span class="keyword">if</span>((m=LocateVex(G,v))&lt;<span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">  G.vexs[m]&lt;-&gt;G.vexs[n]; <span class="comment">//将待删除顶点交换到最后一个顶点</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    G.arcs[i][m]=G.arcs[i][n];</span><br><span class="line">    G.arcs[m][i]=G.arcs[n][i]; <span class="comment">//将边的关系随之交换</span></span><br><span class="line">  &#125;</span><br><span class="line">  G.arcs[m][m].adj=<span class="number">0</span>;</span><br><span class="line">  G.vexnum--;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//Delete_Vex</span></span><br><span class="line">分析:如果不把待删除顶点交换到最后一个顶点的话,算法将会比较复杂,而伴随着大量元素的移动,时间复杂度也会大大增加. </span><br><span class="line">Status <span class="title function_">Delete_Arc</span><span class="params">(MGraph &amp;G,<span class="type">char</span> v,<span class="type">char</span> w)</span><span class="comment">//在邻接矩阵表示的图G上删除边(v,w)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>((i=LocateVex(G,v))&lt;<span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>((j=LocateVex(G,w))&lt;<span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(G.arcs[i][j].adj)</span><br><span class="line">  &#123;</span><br><span class="line">    G.arcs[i][j].adj=<span class="number">0</span>;</span><br><span class="line">    G.arcnum--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//Delete_Arc </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-22"><a href="#7-22" class="headerlink" title="7.22"></a>7.22</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> visited[MAXSIZE]; <span class="comment">//指示顶点是否在当前路径上 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">exist_path_DFS</span><span class="params">(ALGraph G,<span class="type">int</span> i,<span class="type">int</span> j)</span><span class="comment">//深度优先判断有向图G中顶点i到顶点j是否有路径,是则返回1,否则返回0</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(i==j) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//i就是j</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    visited[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)</span><br><span class="line">    &#123;</span><br><span class="line">      k=p-&gt;adjvex;</span><br><span class="line">      <span class="keyword">if</span>(!visited[k]&amp;&amp;exist_path(k,j)) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//i下游的顶点到j有路径</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">  &#125;<span class="comment">//else</span></span><br><span class="line">&#125;<span class="comment">//exist_path_DFS </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-23"><a href="#7-23" class="headerlink" title="7.23"></a>7.23</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">exist_path_BFS</span><span class="params">(ALGraph G,<span class="type">int</span> i,<span class="type">int</span> j)</span><span class="comment">//广度优先判断有向图G中顶点i到顶点j是否有路径,是则返回1,否则返回0</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> visited[MAXSIZE];</span><br><span class="line">  InitQueue(Q);</span><br><span class="line">  EnQueue(Q,i);</span><br><span class="line">  <span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">  &#123;</span><br><span class="line">    DeQueue(Q,u);</span><br><span class="line">    visited[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)</span><br><span class="line">    &#123;</span><br><span class="line">      k=p-&gt;adjvex;</span><br><span class="line">      <span class="keyword">if</span>(k==j) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(!visited[k]) EnQueue(Q,k);</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">  &#125;<span class="comment">//while</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//exist_path_BFS </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-27"><a href="#7-27" class="headerlink" title="7.27"></a>7.27</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> visited[MAXSIZE]; </span><br><span class="line"><span class="type">int</span> <span class="title function_">exist_path_len</span><span class="params">(ALGraph G,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k)</span><span class="comment">//判断邻接表方式存储的有向图G的顶点i到j是否存在长度为k的简单路径</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(i==j&amp;&amp;k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//找到了一条路径,且长度符合要求</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    visited[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)</span><br><span class="line">    &#123;</span><br><span class="line">      l=p-&gt;adjvex;</span><br><span class="line">      <span class="keyword">if</span>(!visited[l])</span><br><span class="line">        <span class="keyword">if</span>(exist_path_len(G,l,j,k<span class="number">-1</span>)) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//剩余路径长度减一</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    visited[i]=<span class="number">0</span>; <span class="comment">//本题允许曾经被访问过的结点出现在另一条路径中</span></span><br><span class="line">  &#125;<span class="comment">//else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//没找到</span></span><br><span class="line">&#125;<span class="comment">//exist_path_len </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="7-42"><a href="#7-42" class="headerlink" title="7.42"></a>7.42</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ALGraph_DIJ</span><span class="params">(ALGraph G,<span class="type">int</span> v0,Pathmatrix &amp;P,ShortestPathTable &amp;D)</span><span class="comment">//在邻接表存储结构上实现迪杰斯特拉算法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;v++)</span><br><span class="line">    D[v]=INFINITY;</span><br><span class="line">  <span class="keyword">for</span>(p=G.vertices[v0].firstarc;p;p=p-&gt;nextarc)</span><br><span class="line">    D[p-&gt;adjvex]=*p-&gt;info; <span class="comment">//给D数组赋初值</span></span><br><span class="line">  <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;v++)</span><br><span class="line">  &#123;</span><br><span class="line">    final[v]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++) P[v][w]=<span class="number">0</span>; <span class="comment">//设空路径</span></span><br><span class="line">    <span class="keyword">if</span>(D[v]&lt;INFINITY)</span><br><span class="line">    &#123;</span><br><span class="line">      P[v][v0]=<span class="number">1</span>;</span><br><span class="line">      P[v][v]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//for</span></span><br><span class="line">  D[v0]=<span class="number">0</span>;final[v0]=<span class="number">1</span>; <span class="comment">//初始化</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;G.vexnum;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    min=INFINITY;</span><br><span class="line">    <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)</span><br><span class="line">      <span class="keyword">if</span>(!final[w])</span><br><span class="line">        <span class="keyword">if</span>(D[w]&lt;min) <span class="comment">//尚未求出到该顶点的最短路径</span></span><br><span class="line">        &#123;</span><br><span class="line">          v=w;</span><br><span class="line">          min=D[w];</span><br><span class="line">        &#125;</span><br><span class="line">    final[v]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(p=G.vertices[v].firstarc;p;p=p-&gt;nextarc)</span><br><span class="line">    &#123;</span><br><span class="line">      w=p-&gt;adjvex;</span><br><span class="line">      <span class="keyword">if</span>(!final[w]&amp;&amp;(min+(*p-&gt;info)&lt;D[w])) <span class="comment">//符合迪杰斯特拉条件</span></span><br><span class="line">      &#123;</span><br><span class="line">        D[w]=min+edgelen(G,v,w);</span><br><span class="line">        P[w]=P[v];</span><br><span class="line">        P[w][w]=<span class="number">1</span>; <span class="comment">//构造最短路径</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">  &#125;<span class="comment">//for</span></span><br><span class="line">&#125;<span class="comment">//ALGraph_DIJ</span></span><br><span class="line">分析:本算法对迪杰斯特拉算法中直接取任意边长度的语句作了修改.由于在原算法中,每次循环都是对尾相同的边进行处理,所以可以用遍历邻接表中的一条链来代替.</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>##第九章</p>
<h3 id="9-25"><a href="#9-25" class="headerlink" title="9.25"></a>9.25</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Search_Sq</span><span class="params">(SSTable ST,<span class="type">int</span> key)</span><span class="comment">//在有序表上顺序查找的算法,监视哨设在高下标端</span></span><br><span class="line">&#123;</span><br><span class="line">  ST.elem[ST.length+<span class="number">1</span>].key=key;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;ST.elem[i].key&gt;key;i++);</span><br><span class="line">  <span class="keyword">if</span>(i&gt;ST.length||ST.elem[i].key&lt;key) <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;<span class="comment">//Search_Sq</span></span><br><span class="line">分析:本算法查找成功情况下的平均查找长度为ST.length/<span class="number">2</span>,不成功情况下为ST.length.</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="9-26"><a href="#9-26" class="headerlink" title="9.26"></a>9.26</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Search_Bin_Recursive</span><span class="params">(SSTable ST,<span class="type">int</span> key,<span class="type">int</span> low,<span class="type">int</span> high)</span><span class="comment">//折半查找的递归算法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(low&gt;high) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//查找不到时返回0</span></span><br><span class="line">  mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(ST.elem[mid].key==key) <span class="keyword">return</span> mid;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ST.elem[mid].key&gt;key)</span><br><span class="line">    <span class="keyword">return</span> Search_Bin_Recursive(ST,key,low,mid<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> Search_Bin_Recursive(ST,key,mid+<span class="number">1</span>,high);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">//Search_Bin_Recursive </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="9-31"><a href="#9-31" class="headerlink" title="9.31"></a>9.31</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> last=<span class="number">0</span>,flag=<span class="number">1</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">Is_BSTree</span><span class="params">(Bitree T)</span><span class="comment">//判断二叉树T是否二叉排序树,是则返回1,否则返回0</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(T-&gt;lchild&amp;&amp;flag) Is_BSTree(T-&gt;lchild);</span><br><span class="line">  <span class="keyword">if</span>(T-&gt;data&lt;last) flag=<span class="number">0</span>; <span class="comment">//与其中序前驱相比较</span></span><br><span class="line">  last=T-&gt;data;</span><br><span class="line">  <span class="keyword">if</span>(T-&gt;rchild&amp;&amp;flag) Is_BSTree(T-&gt;rchild);</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;<span class="comment">//Is_BSTree </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><h3 id="10-23"><a href="#10-23" class="headerlink" title="10.23"></a>10.23</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Insert_Sort1</span><span class="params">(SqList &amp;L)</span><span class="comment">//监视哨设在高下标端的插入排序算法</span></span><br><span class="line">&#123;</span><br><span class="line">  k=L.length;</span><br><span class="line">  <span class="keyword">for</span>(i=k<span class="number">-1</span>;i;--i) <span class="comment">//从后向前逐个插入排序</span></span><br><span class="line">    <span class="keyword">if</span>(L.r[i].key&gt;L.r[i+<span class="number">1</span>].key)</span><br><span class="line">    &#123;</span><br><span class="line">      L.r[k+<span class="number">1</span>].key=L.r[i].key; <span class="comment">//监视哨</span></span><br><span class="line">      <span class="keyword">for</span>(j=i+<span class="number">1</span>;L.r[j].key&gt;L.r[i].key;++j)</span><br><span class="line">        L.r[j<span class="number">-1</span>].key=L.r[j].key; <span class="comment">//前移</span></span><br><span class="line">      L.r[j<span class="number">-1</span>].key=L.r[k+<span class="number">1</span>].key; <span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//Insert_Sort1 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10-31"><a href="#10-31" class="headerlink" title="10.31"></a>10.31</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10.31</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Divide</span><span class="params">(<span class="type">int</span> a[ ],<span class="type">int</span> n)</span><span class="comment">//把数组a中所有值为负的记录调到非负的记录之前</span></span><br><span class="line">&#123;</span><br><span class="line">  low=<span class="number">0</span>;high=n<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high&amp;&amp;a[high]&gt;=<span class="number">0</span>) high--; <span class="comment">//以0作为虚拟的枢轴记录</span></span><br><span class="line">    a[low]&lt;-&gt;a[high];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high&amp;&amp;a[low]&lt;<span class="number">0</span>) low++;</span><br><span class="line">    a[low]&lt;-&gt;a[high];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">//Divide</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10-32"><a href="#10-32" class="headerlink" title="10.32"></a>10.32</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>RED,WHITE,BLUE&#125; color; <span class="comment">//三种颜色 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Flag_Arrange</span><span class="params">(color a[ ],<span class="type">int</span> n)</span><span class="comment">//把由三种颜色组成的序列重排为按照红,白,蓝的顺序排列</span></span><br><span class="line">&#123;</span><br><span class="line">  i=<span class="number">0</span>;j=<span class="number">0</span>;k=n<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(j&lt;=k)</span><br><span class="line">    <span class="keyword">switch</span>(a[j])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> RED:</span><br><span class="line">        a[i]&lt;-&gt;a[j];</span><br><span class="line">        i++;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> WHITE:</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> BLUE:</span><br><span class="line">        a[j]&lt;-&gt;a[k];</span><br><span class="line">        k--; <span class="comment">//这里没有j++;语句是为了防止交换后a[j]仍为蓝色的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//Flag_Arrange</span></span><br><span class="line">分析:这个算法中设立了三个指针.其中,j表示当前元素;i以前的元素全部为红色;k以后的元素全部为蓝色.这样,就可以根据j的颜色,把其交换到序列的前部或者后部. </span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://jiahuikang.github.io/img/whiteBG.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/06/16/%E6%B9%96%E9%9D%A2%E7%A7%AF%E5%BB%BA%E6%A8%A1/"><img class="next-cover" src="https://jiahuikang.github.io/img/lake.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">海大图书馆前湖面积建模</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">雲陽</div><div class="author-info__description">别往下看了，这里什么都没有</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0"><span class="toc-number">1.</span> <span class="toc-text">第二章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11"><span class="toc-number">1.1.</span> <span class="toc-text">2.11</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-19"><span class="toc-number">1.2.</span> <span class="toc-text">2.19</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-22"><span class="toc-number">1.3.</span> <span class="toc-text">2.22</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-25"><span class="toc-number">1.4.</span> <span class="toc-text">2.25</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-26"><span class="toc-number">1.5.</span> <span class="toc-text">2.26</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-33"><span class="toc-number">1.6.</span> <span class="toc-text">* 2.33</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0"><span class="toc-number">2.</span> <span class="toc-text">第三章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-17"><span class="toc-number">2.1.</span> <span class="toc-text">* 3.17</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-18"><span class="toc-number">2.2.</span> <span class="toc-text">* 3.18</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-19"><span class="toc-number">2.3.</span> <span class="toc-text">3.19</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-21"><span class="toc-number">2.4.</span> <span class="toc-text">3.21</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-28"><span class="toc-number">2.5.</span> <span class="toc-text">3.28</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-31"><span class="toc-number">2.6.</span> <span class="toc-text">* 3.31</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-32"><span class="toc-number">2.7.</span> <span class="toc-text">* 3.32</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0"><span class="toc-number">3.</span> <span class="toc-text">第五章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-31"><span class="toc-number">3.1.</span> <span class="toc-text">5.31</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-38"><span class="toc-number">3.2.</span> <span class="toc-text">5.38</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0"><span class="toc-number">4.</span> <span class="toc-text">第六章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-33"><span class="toc-number">4.1.</span> <span class="toc-text">6.33</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-36"><span class="toc-number">4.2.</span> <span class="toc-text">6.36</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-37"><span class="toc-number">4.3.</span> <span class="toc-text">6.37</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-38"><span class="toc-number">4.4.</span> <span class="toc-text">6.38</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-39"><span class="toc-number">4.5.</span> <span class="toc-text">6.39</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-41"><span class="toc-number">4.6.</span> <span class="toc-text">6.41</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-42"><span class="toc-number">4.7.</span> <span class="toc-text">6.42</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-43"><span class="toc-number">4.8.</span> <span class="toc-text">6.43</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-47"><span class="toc-number">4.9.</span> <span class="toc-text">6.47</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-49"><span class="toc-number">4.10.</span> <span class="toc-text">6.49</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-60"><span class="toc-number">4.11.</span> <span class="toc-text">6.60</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-62"><span class="toc-number">4.12.</span> <span class="toc-text">6.62</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-65"><span class="toc-number">4.13.</span> <span class="toc-text">6.65</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0"><span class="toc-number">5.</span> <span class="toc-text">第七章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-15"><span class="toc-number">5.1.</span> <span class="toc-text">7.15</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-22"><span class="toc-number">5.2.</span> <span class="toc-text">7.22</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-23"><span class="toc-number">5.3.</span> <span class="toc-text">7.23</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-27"><span class="toc-number">5.4.</span> <span class="toc-text">7.27</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-42"><span class="toc-number">5.5.</span> <span class="toc-text">7.42</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-25"><span class="toc-number">5.6.</span> <span class="toc-text">9.25</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-26"><span class="toc-number">5.7.</span> <span class="toc-text">9.26</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-31"><span class="toc-number">5.8.</span> <span class="toc-text">9.31</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0"><span class="toc-number">6.</span> <span class="toc-text">第十章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-23"><span class="toc-number">6.1.</span> <span class="toc-text">10.23</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-31"><span class="toc-number">6.2.</span> <span class="toc-text">10.31</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-32"><span class="toc-number">6.3.</span> <span class="toc-text">10.32</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%9A%E7%AD%94%E6%A1%88/" title="数据结构算法作业答案"><img src="https://jiahuikang.github.io/img/whiteBG.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构算法作业答案"/></a><div class="content"><a class="title" href="/2023/06/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%9A%E7%AD%94%E6%A1%88/" title="数据结构算法作业答案">数据结构算法作业答案</a><time datetime="2023-06-21T15:08:47.096Z" title="发表于 2023-06-21 23:08:47">2023-06-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/16/%E6%B9%96%E9%9D%A2%E7%A7%AF%E5%BB%BA%E6%A8%A1/" title="海大图书馆前湖面积建模"><img src="https://jiahuikang.github.io/img/lake.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="海大图书馆前湖面积建模"/></a><div class="content"><a class="title" href="/2023/06/16/%E6%B9%96%E9%9D%A2%E7%A7%AF%E5%BB%BA%E6%A8%A1/" title="海大图书馆前湖面积建模">海大图书馆前湖面积建模</a><time datetime="2023-06-15T17:18:02.883Z" title="发表于 2023-06-16 01:18:02">2023-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%9B%9B/" title="Experiment 4"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Experiment 4"/></a><div class="content"><a class="title" href="/2023/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%9B%9B/" title="Experiment 4">Experiment 4</a><time datetime="2023-06-14T15:52:17.111Z" title="发表于 2023-06-14 23:52:17">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/01/%E7%AE%97%E6%95%B0%E7%A7%BB%E4%BD%8D%E8%A1%A5%E7%AC%A6%E5%8F%B7%E4%BD%8D%E7%9A%84%E5%8E%9F%E7%90%86/" title="数学思想与文化论文"><img src="https://jiahuikang.github.io/img/head.JPG" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数学思想与文化论文"/></a><div class="content"><a class="title" href="/2023/01/01/%E7%AE%97%E6%95%B0%E7%A7%BB%E4%BD%8D%E8%A1%A5%E7%AC%A6%E5%8F%B7%E4%BD%8D%E7%9A%84%E5%8E%9F%E7%90%86/" title="数学思想与文化论文">数学思想与文化论文</a><time datetime="2022-12-31T16:47:48.154Z" title="发表于 2023-01-01 00:47:48">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/28/hello-world/" title="到此一游"><img src="/img/background.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="到此一游"/></a><div class="content"><a class="title" href="/2022/12/28/hello-world/" title="到此一游">到此一游</a><time datetime="2022-12-28T15:19:29.706Z" title="发表于 2022-12-28 23:19:29">2022-12-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 雲陽</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><link rel="stylesheet" href="/css/co.css"><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>